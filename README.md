# OOD-Assignment1
به نام خدا

تمرین شماره 1: آشنایی با اصول شی گرایی( موسوم به اصول SOLID)
| شماره دانشجویی | نام دانشجو |
| :---: | :---: |
| 4022170125 | فاطمه محجوب |
| 4022170126 | رضوان محمدی |

اهداف

در این آزمایش هدف بر آن است که دانشجویان با به کارگیری اصول SOLID در یک پروژه‌ی عملی ساده آشنا شوند.

مقدمه

در این آزمایش شما خواهید آموخت که چگونه می‌توانید با به کارگیری اصول SOLID، نرم‌افزارهایی را بسازید که از نظر قابلیت نگهداری و بهبود، در وضعیت مطلوبی باشند و مدیریت تغییرات در آن‌ها به آسانی میسر باشد.

## **گام ۱: افزودن دو قابلیت جدید و ثبت تغیرات**

در این گام، قابلیت‌های پیامک (SMS) و پرداخت حضوری (On-Site) به کد اولیه اضافه شدند:

الف) تغییرات مربوط به افزودن روش جدید ارسال پیام (SMS) – توسط رضوان محمدی

<div dir="rtl">

| ردیف | کلاس تغیر یافته | تغییر اعمال شده (نوع) | توضیح کوتاه در مورد تغییرات |
| :---: | :---: | :---: | :---: |
| **۱** | `Notifire.java` | ویرایش (افزودن مقدار) | افزودن مقدار **`SMS`** به `enum Notifier` برای تعریف نوع جدید اعلان در سیستم |
| **۲** | `MessageSender.java` | ویرایش (افزودن متد) | افزودن متد **`SendSms`** به واسط.این کار واسط را گسترده تر می کند و یک نقض عمدی `ISP` را برای پیاده سازی ها تحمیل می کند.
| **۲** | `SmsSender.java` | افزودن (کلاس جدید) | ایجاد کلاس جدید **`SmsSender`** حاوی متد `sendSms()` برای پیاده‌سازی منطق ارسال پیامک |
| **۳** | `ReservationService.java` | ویرایش (افزودن بلوک شرطی) | افزودن یک بلوک **`case SMS`** درون `switch (this.notifier)`  |

</div>

ب) تغییرات مربوط به افزودن روش جدید پرداخت (On-Site Payment) – توسط فاطمه محجوب


<div dir="rtl">

| ردیف | کلاس تغییر یافته | تغییرات اعمال شده | توضیح کوتاه در مورد تغییر |
| :---: | :---: | :---: | :---: |
| **۱** | `PaymentMethods.java` | `ONSITE` (افزوده شده به `enum`) | افزودن نوع پرداخت جدید به سیستم |
| **۲** | `PaymentProcessor.java` | `public void payOnSite(double amount)` | افزودن متد اجرای منطق پرداخت حضوری |
| **۳** | `ReservationService.java` | افزودن `case ONSITE:` و فراخوانی `payOnSite()` | افزودن شرط برای هندل کردن پرداخت حضوری در ساختار `switch` |

</div>







## **گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID**
<div dir="rtl">

| اصل | مورد | کلاس / متد | علت برقراری / نقض |
| :---: | :---: | :---: | :---: |
| **SRP** | برقراری | `Customer.java`<br>`Room.java` | فقط مسئولیت نگهداری داده‌های مشتری را دارد.<br>فقط مسئول نگهداری داده های مربوط به یک اتاق (شماره و نوع و قیمت) است. |
| **SRP** | نقض | `ReservationService.java`<br>`PaymentProcessor.java` | `ReservationService` بیش از یک مسئولیت (رزرو و مدیریت تخفیف، پرداخت و اطلاع‌رسانی) را بر عهده دارد.<br>کلاس `PaymentProcessor` مسئولیت انجام چند نوع عملیات پرداخت مجزا (کارت، نقد، پی‌پال) را بر عهده دارد. |
| **OCP** | برقراری | `Room.java`, `LuxuryRoom.java` | کلاس `LuxuryRoom` بدون نیاز به تغییر کلاس پایه `Room`، آن را گسترش داده است. |
| **OCP** | نقض | `ReservationService.java` و `PaymentProcessor.java` | در `ReservationService`، کلاس برای تغییر بسته نیست. با اضافه شدن هر روش جدید پرداخت (مثلاً ONSITE) یا اعلان (مثلاً SMS)، بلوک‌های `switch` باید تغییر کنند. <br> علاوه بر این، برای اضافه کردن تخفیف شهر جدید (مثلاً رم)، مجبور هستیم یک بلوک `else if` جدید به کد موجود اضافه کنیم. <br><br> در `PaymentProcessor` اگر بخواهیم یک روش پرداخت جدید اضافه کنیم، مجبور هستیم به کد کلاس یک متد جدید اضافه کنیم. |
| **LSP** | برقراری | `Room.java`, `LuxuryRoom.java` | نمونه کلاس فرزند (`LuxuryRoom`) می‌تواند بدون برهم زدن رفتار برنامه جایگزین نمونه کلاس والد (`Room`) در `Reservation` و سایر نقاط شود |
| **LSP** | نقض |  |  |
| **ISP** | برقراری | `MessageSender.java`, `EmailSender.java` | در حال حاضر، واسط `MessageSender` کوچک است و کلاس `EmailSender` فقط متدی را پیاده‌سازی کرده که به آن نیاز دارد |
| **ISP** | نقض | `MessageSender.java` | واسط به اندازه کافی عمومی نیست؛ نام متد `sendEmail` کلاس‌های آینده (مانند `SmsSender`) را مجبور می‌کند که متدی را پیاده‌سازی کنند که به وظیفه اصلی آن‌ها مربوط نیست |
| **DIP** | برقراری | ندارد | کلاس اصلی فاقد تزریق وابستگی از طریق واسط‌هاست |
| **DIP** | نقض | `ReservationService.java` | ماژول سطح بالا (`ReservationService`) به جای وابستگی به یک انتزاع (`Interface`)، مستقیماً شیء کلاس سطح پایین `EmailSender` را با `new` ایجاد می‌کند |
| **PLK** | برقراری | `Reservation.java` | متد `totalPrice()` برای محاسبه از فیلد `nights` (عضو مستقیم خودش) و شی مستقیم `room` استفاده می‌کند |
| **PLK** | نقض | `ReservationService.makeReservation()` | کلاس `ReservationService` به جزئیات پیاده‌سازی داخلی (ساختار فیلدهای عمومی) کلاس‌های `Reservation`, `Customer` و `Room` وابسته می‌شود و این امر کپسوله‌سازی را نقض می‌کند |
| **CRP** | برقراری | `ReservationService.java`<br>`PaymentProcessor.java`<br>`Reservation.java`<br>`LuxuryRoom.java` | کلاس `ReservationService` برای استفاده از قابلیت‌های پرداخت، از ترکیب (`Composition`) با `PaymentProcessor` استفاده کرده است.<br><br>کلاس `ReservationService` برای دسترسی به داده‌ها و منطق `Reservation` (مانند محاسبه قیمت)، به جای ارث‌بری، از ترکیب استفاده کرده است.<br>کلاس `Reservation` برای استفاده از داده‌های `Room` و `Customer` به جای ارث‌بری از آن‌ها، از ترکیب استفاده کرده است و این کلاس نمونه‌ای از `Room` و `Customer` را به عنوان فیلد نگهداری می‌کند.<br><br>در `LuxuryRoom` از وراثت برای استفاده مجدد از کدهای عملیاتی (متد) کلاس والد استفاده نشده است و صرفاً مدل‌سازی صحیح رابطه "یک نوع از" (Is-A) در ساختار اتاق‌ها بوده است. |
| **CRP** | نقض | ندارد | در کدهای اولیه، مثال مشخصی از نقض `CRP` مشاهده نمی‌شود |

</div>

<div dir="rtl">

## **گام ۳: اصلاح نقض‌ها و برقراری اصول SOLID**




| اصل مربوطه | مشکل در کد اولیه | راه‌حل پیشنهادی در کد تغییر یافته |
| :---: | :---: | :---: |
| **SRP** | کلاس `PaymentProcessor.java` چندین وظیفه متفاوت (پرداخت با کارت، نقدی، پی‌پال) را در یک کلاس واحد انجام می‌داد. در نتیجه، این کلاس چندین دلیل برای تغییر داشت. | کلاس `PaymentProcessor` حذف شد و به واسط `PaymentService` و کلاس‌های تفکیک‌شده (`CardPaymentService`، `PayPalPaymentService` و `CashPaymentService`) تبدیل شد. |
| **SRP** | کلاس `ReservationService` نیز مستقیماً به جزئیات پیاده‌سازی متدهای اختصاصی (مانند `payByCard`) در `PaymentProcessor` وابسته بود. | وابستگی مستقیم به `PaymentProcessor` حذف شد. متغیر `processor` از نوع واسط `PaymentService` تعریف شد و اجرای نهایی عملیات پرداخت تنها با یک فراخوانی عمومی (`processor.processPayment(res.totalPrice());`) انجام گرفت. این کار مسئولیت اجرای دقیق پرداخت را به کلاس‌های جدید منتقل کرد. |
| **SRP** | علاوه بر این، کلاس `ReservationService` نیز چندین مسئولیت مستقل را با هم ترکیب کرده بود: مدیریت رزرو و اعمال تخفیف، مدیریت پرداخت، و مدیریت اطلاع‌رسانی (سه دلیل برای تغییر). | وظایف اضافی به کلاس‌های تخصصی منتقل شدند: اعمال تخفیف به `DiscountStrategy` و چاپ فاکتور به `InvoicePrinter`. همچنین، وابستگی به سرویس‌ها (پرداخت، اطلاع‌رسانی) از طریق متغیر payment از نوع واسط `PaymentService` و متغیر notifier از نوع واسط `MessageSender` و صدا زدن متدهای مربوطه انجام شد. این امر `ReservationService` را به یک هماهنگ‌کننده تبدیل کرد و SRP به طور کامل برقرار شد. |
| **OCP** | در `PaymentProcessor` افزودن هر روش پرداخت جدید نیازمند تغییر مستقیم در کد کلاس و افزودن یک متد جدید به آن است. | یک `interface` به نام `PaymentService` ساختیم که متد عمومی `processPayment(double amount)` را تعریف می‌کند. <br> هر نوع پرداخت را در یک کلاس و فایل جداگانه ایجاد کردیم (`CardPaymentService`، `CashPaymentService`، `PayPalPaymentService`) و هر یک از این کلاس‌های جدید، متد `processPayment(double amount)` داخل واسط `PaymentService` را پیاده‌سازی کردند. |
| **OCP** | کلاس `ReservationService` به شدت به جزئیات پیاده‌سازی متدهای پرداخت و اطلاع‌رسانی وابسته بود. این وابستگی از طریق استفاده از بلوک‌های `switch` برای مدیریت Enumsهای `PaymentMethods` و `Notifier` ایجاد شده بود. در نتیجه، افزودن هر روش پرداخت یا اعلان‌کننده جدید نیازمند تغییر کد داخلی متد `makeReservation` بود. | متد `makeReservation` اکنون متغیر `payment` از نوع اینترفیس `PaymentService` و متغیر `notifier` از نوع اینترفیس `MessageSender` را به عنوان پارامتر دریافت می‌کند. با این کار، کلاس `ReservationService` دیگر نیازی به دانستن نوع پرداخت یا اعلان‌کننده ندارد و فقط متدهای عمومی را فراخوانی می‌کند. این ساختار تضمین می‌کند که کلاس برای تغییر بسته و برای گسترش باز است. <br> <br> تغییرات در Main: چون بلوک‌های `switch` پرداخت و اطلاع‌رسانی از `ReservationService` حذف شدند، خطوط زیر به `Main` اضافه شدند تا ابزارهای مورد نظر را آماده کنند: <br> `PaymentService paypalProcessor = new PayPalPaymentService();` و `MessageSender emailSender = new EmailSender();` به `Main` اضافه شدند تا پرداخت (مانند پی‌پال) و اطلاع‌رسانی (مانند ایمیل) مورد نظر مشتری را برای متد `makeReservation` آماده کنند و مستقیماً تحویل دهند. |
| **OCP** | حتی پس از جدا شدن مسئولیت تخفیف از `ReservationService`، سیستم در جایی دیگر مجبور بود برای هر شهر جدید (مثل لندن یا رم) که تخفیف داشت، یک خط `else if` جدید به کد موجود اضافه کند. | برای قانون تخفیف هر شهر یک کلاس و فایل جداگانه (مثل `ParisDiscountStrategy`) ساختیم. این کار تضمین می‌کند که افزودن تخفیف جدید، فقط نیاز به ساخت یک فایل جدید داشته باشد و کد موجود تغییر نکند. <br> کلاس `CompositeDiscountService` را ساختیم تا نقش مدیر تخفیف‌ها را ایفا کند و تمام قوانین تفکیک شده را به‌صورت یک لیست در خود جای دهد و روی همه‌ی آن‌ها اجرا شود. <br> تغییرات در Main: این تغییرات صرفاً برای آماده‌سازی و تحویل این ساختار جدید به `ReservationService` انجام شدند: <br> `DiscountStrategy parisDiscount = new ParisDiscountStrategy();`: این خط شیئی را برای تخفیف پاریس می‌سازد. <br> `List<DiscountStrategy> allDiscounts = List.of(parisDiscount);`: این خط تمام قوانین فعال تخفیف را در یک لیست جمع‌آوری می‌کند. <br> `DiscountStrategy compositeDiscountService = new CompositeDiscountService(allDiscounts);`: این خط مسئول مدیریت تخفیف‌ها است تا مشخص شود با توجه به اطلاعات مشتری کدام تخفیف باید اعمال شود. <br> در نهایت، این شیء به `ReservationService` تحویل داده می‌شود. |
| **ISP** | واسط `MessageSender` با نام متد `sendEmail`، پیاده‌سازی را محدود به ایمیل می‌کرد و افزودن روش‌های اطلاع‌رسانی جدید (مانند `SMS`) نیاز به تغییر نام متد داشت. این واسط نقض اصل `ISP` بود زیرا هدفی محدودکننده داشت. | نام متد در واسط `MessageSender` به `sendMessage` تغییر یافت تا عمومی‌تر باشد و امکان پیاده‌سازی برای انواع مختلف اطلاع‌رسانی (`Email`, `SMS`, `Push`) فراهم شود. کلاس `EmailSender` نیز با تغییر نام متد به `sendMessage` و اضافه کردن `@Override` با این واسط جدید هماهنگ شد. این کار واسط را کوچک، متمرکز و قابل گسترش نگه داشت. |
| **PLK** | کلاس `ReservationService` به طور مستقیم و بدون واسطه به فیلدهای داخلی اشیای `Reservation`، `Customer` و `Room` دسترسی داشت: `res.customer.city`، `res.customer.name`، `res.customer.email`، `res.room.price`، `res.room.number` و `res.room.type`. این نقض شدید اصل `PLK` بود و وابستگی زیادی بین کلاس‌ها ایجاد می‌کرد. | دسترسی مستقیم به فیلدها حذف شد. در کلاس‌های `Customer` و `Room` فیلدها از `public` به `private` تغییر یافتند و متدهای getter مناسب (`getName` ، `getEmail` ، `getPrice` ، `getNumber` ، `getType`) اضافه شدند. همچنین رفتارهای خاص مانند بررسی شهر (`isCity`) و اعمال تخفیف (`applyDiscount`) کپسوله شدند. در کلاس `Reservation` نیز فیلدها `private` شدند و متدهای واسط مانند `isCustomerFromCity`، `getCustomerEmail`، `getCustomerName`، `getRoomNumber`، `getRoomType` و `applyDiscountToRoom` اضافه شدند تا `ReservationService` تنها از طریق این متدها با اشیا تعامل کند. |
| **PLK** | کلاس‌های مدل (`Customer`، `Room` و `Reservation`) به گونه‌ای طراحی شده بودند که تمام فیلدهای آن‌ها `public` و قابل دسترسی مستقیم بودند. این طراحی، امکان دسترسی و تغیر غیرقابل کنترل داده هارا فراهم می کرد و اصل کپسوله سازی را نقض می‌نمود. | در هر سه کلاس `Customer`، `Room` و `Reservation` کلیه فیلدها از `public` به `private` تغییر داده شدند. برای هر فیلد لازم، متدهای getter عمومی تعریف شد تا دسترسی کنترل‌شده فراهم شود. این تغییرات کپسوله‌سازی داده‌ها را برقرار کرده و مانع وابستگی مستقیم سایر کلاس‌ها به ساختار داخلی این مدل‌ها شد. |
| **DIP** | کلاس `ReservationService` به طور مستقیم به پیاده‌سازی‌های مشخص (`EmailSender` و `PaymentProcessor`) وابسته بود. این وابستگی‌ها در داخل متد `makeReservation` (با ایجاد نمونه از `EmailSender`) و در فیلدهای عضو کلاس (`private PaymentProcessor paymentProcessor = new PaymentProcessor()`) دیده می‌شد. این طراحی، `ReservationService` را به جزئیات پیاده‌سازی گره زده بود. | وابستگی‌های `ReservationService` به سطوح انتزاعی تغییر یافت. به جای وابستگی مستقیم به `EmailSender`، به واسط `MessageSender` وابسته شد. همچنین به جای ایجاد داخلی `PaymentProcessor`، این وابستگی از طریق سازنده (`constructor injection`) دریافت شد. سازنده کلاس به `public ReservationService(MessageSender sender, PaymentProcessor processor)` تغییر یافت. در نتیجه `ReservationService` دیگر از جزئیات پیاده‌سازی اطلاعی ندارد. |
| **DIP** | در نقطه آغاز برنامه (`Main`)، کلاس `ReservationService` بدون ارسال وابستگی‌ها ساخته می‌شد. این موضوع باعث نقض `DIP` در سطح بالاتر و عدم امکان تزریق پیاده‌سازی‌های جایگزین بود. | منطق ایجاد و تزریق وابستگی‌ها به کلاس `Main` منتقل شد. اشیای `EmailSender` و `PaymentProcessor` در `Main` ساخته شدند و سپس از طریق سازنده جدید به `ReservationService` تزریق شدند: `ReservationService service = new ReservationService(emailSender, paymentProcessor);` این تغییر کنترل وابستگی‌ها را به لایه بالاتر داد و `DIP` را در تمامی سطوح برقرار کرد. |
| **DIP** | کلاس‌های سطح پایین (`EmailSender` و `PaymentProcessor`) با سطح دسترسی بسته (`package-private`) تعریف شده بودند و استفاده از آن‌ها در بسته‌های دیگر (مثلاً بسته `Main`) را غیرممکن می‌کرد، که مانع تزریق صحیح وابستگی‌ها می‌شد. | سطح دسترسی هر دو کلاس `EmailSender` و `PaymentProcessor` به `public` تغییر یافت. این کار ضروری بود تا کلاس `Main` بتواند نمونه‌های این کلاس‌ها را ساخته و به `ReservationService` تزریق کند. بدون این تغییر، اجرای کامل `DIP` ممکن نبود. |



</div>
