# OOD-Assignment1
به نام خدا

تمرین شماره 1: آشنایی با اصول شی گرایی( موسوم به اصول SOLID)
| شماره دانشجویی | نام دانشجو |
| :---: | :---: |
| 4022170125 | فاطمه محجوب |
| 4022170126 | رضوان محمدی |

اهداف

در این آزمایش هدف بر آن است که دانشجویان با به کارگیری اصول SOLID در یک پروژه‌ی عملی ساده آشنا شوند.

مقدمه

در این آزمایش شما خواهید آموخت که چگونه می‌توانید با به کارگیری اصول SOLID، نرم‌افزارهایی را بسازید که از نظر قابلیت نگهداری و بهبود، در وضعیت مطلوبی باشند و مدیریت تغییرات در آن‌ها به آسانی میسر باشد.

## **گام ۱: افزودن دو قابلیت جدید و ثبت تغیرات**

در این گام، قابلیت‌های پیامک (SMS) و پرداخت حضوری (On-Site) به کد اولیه اضافه شدند:

الف) تغییرات مربوط به افزودن روش جدید ارسال پیام (SMS) – توسط رضوان محمدی

<div dir="rtl">

| ردیف | کلاس تغیر یافته | تغییر اعمال شده (نوع) | توضیح کوتاه در مورد تغییرات |
| :---: | :---: | :---: | :---: |
| **۱** | `Notifire.java` | ویرایش (افزودن مقدار) | افزودن مقدار **`SMS`** به `enum Notifier` برای تعریف نوع جدید اعلان در سیستم |
| **۲** | `SmsSender.java` | افزودن (کلاس جدید) | ایجاد کلاس جدید **`SmsSender`** حاوی متد `sendSms()` برای پیاده‌سازی منطق ارسال پیامک |
| **۳** | `ReservationService.java` | ویرایش (افزودن بلوک شرطی) | افزودن یک بلوک **`case SMS`** درون `switch (this.notifier)`  |

</div>

ب) تغییرات مربوط به افزودن روش جدید پرداخت (On-Site Payment) – توسط فاطمه محجوب


<div dir="rtl">

| ردیف | کلاس تغییر یافته | تغییرات اعمال شده | توضیح کوتاه در مورد تغییر |
| :---: | :---: | :---: | :---: |
| **۱** | `PaymentMethods.java` | `ONSITE` (افزوده شده به `enum`) | افزودن نوع پرداخت جدید به سیستم |
| **۲** | `PaymentProcessor.java` | `public void payOnSite(double amount)` | افزودن متد اجرای منطق پرداخت حضوری |
| **۳** | `ReservationService.java` | افزودن `case ONSITE:` و فراخوانی `payOnSite()` | افزودن شرط برای هندل کردن پرداخت حضوری در ساختار `switch` |

</div>








## گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID


<div dir="rtl">

| اصل | مورد | کلاس / متد | علت برقراری / نقض |
|:---:|:---:|:---:|:---:|
| **SRP** | برقراری | `Customer.java` | فقط مسئولیت نگهداری داده‌های مشتری را دارد. |
| **SRP** | نقض | `ReservationService.java`<br>`PaymentProcessor.java` | **`ReservationService`** بیش از یک مسئولیت (رزرو و مدیریت تخفیف، پرداخت و اطلاع‌رسانی) را بر عهده دارد.<br>کلاس **`PaymentProcessor`** مسئولیت انجام چند نوع عملیات پرداخت مجزا (کارت، نقد، پی‌پال) را بر عهده دارد. |
| **OCP** | برقراری | `Room.java`, `LuxuryRoom.java` | کلاس `LuxuryRoom` بدون نیاز به تغییر کلاس پایه `Room`، آن را گسترش داده است. |
| **OCP** | نقض | `ReservationService.java` | کلاس برای تغییر بسته نیست. با اضافه شدن هر روش جدید پرداخت (مثلا ONSITE) یا اعلان (مثلا SMS)، بلوک‌های `switch` باید تغییر کنند. |
| **LSP** | برقراری | `Room.java`, `LuxuryRoom.java` | نمونه کلاس فرزند (`LuxuryRoom`) می‌تواند بدون برهم زدن رفتار برنامه جایگزین نمونه کلاس والد (`Room`) در `Reservation` و سایر نقاط شود |
| **LSP** | نقض |  |  |
| **ISP** | برقراری | `MessageSender.java`, `EmailSender.java` | در حال حاضر، واسط `MessageSender` کوچک است و کلاس `EmailSender` فقط متدی را پیاده‌سازی کرده که به آن نیاز دارد |
| **ISP** | نقض | `MessageSender.java` | واسط به اندازه کافی عمومی نیست؛ نام متد `sendEmail` کلاس‌های آینده (مانند `SmsSender`) را مجبور می‌کند که متدی را پیاده‌سازی کنند که به وظیفه اصلی آن‌ها مربوط نیست |
| **DIP** | برقراری | ندارد | کلاس اصلی فاقد تزریق وابستگی از طریق واسط‌هاست |
| **DIP** | نقض | `ReservationService.java` | ماژول سطح بالا (`ReservationService`) به جای وابستگی به یک انتزاع (`Interface`)، مستقیماً شیء کلاس سطح پایین `EmailSender` را با `new` ایجاد می‌کند |
| **PLK** | برقراری | `Reservation.java` | متد `totalPrice()` برای محاسبه از فیلد `nights` (عضو مستقیم خودش) و شی مستقیم `room` استفاده می‌کند |
| **PLK** | نقض | `ReservationService.makeReservation()` | کلاس `ReservationService` به جزئیات پیاده‌سازی داخلی (ساختار فیلدهای عمومی) کلاس‌های `Reservation`, `Customer` و `Room` وابسته می‌شود و این امر کپسوله‌سازی را نقض می‌کند |
| **CRP** | برقراری | `ReservationService.java`<br>`PaymentProcessor.java`<br>`Reservation.java` | کلاس `ReservationService` برای استفاده از قابلیت‌های پرداخت، از ترکیب (`Composition`) با `PaymentProcessor` استفاده کرده است.<br>کلاس `ReservationService` برای دسترسی به داده‌ها و منطق `Reservation` (مانند محاسبه قیمت)، به جای ارث‌بری، از ترکیب استفاده کرده است.<br>کلاس `Reservation` برای استفاده از داده‌های `Room` و `Customer` به جای ارث‌بری از آن‌ها، از ترکیب استفاده کرده است و این کلاس نمونه‌ای از `Room` و `Customer` را به عنوان فیلد نگهداری می‌کند. |
| **CRP** | نقض | ندارد | در کدهای اولیه، مثال مشخصی از نقض `CRP` مشاهده نمی‌شود |

</div>

<div dir="rtl">

## گام ۳: اصلاح نقض‌ها و برقراری اصول SOLID




| اصل مربوطه | مشکل در کد اولیه | راه‌حل پیشنهادی در کد تغییر یافته |
| :---: | :---: | :---: |
| **SRP** | کلاس `PaymentProcessor.java` چندین وظیفه متفاوت (پرداخت با کارت، نقدی، پی‌پال) را در یک کلاس واحد انجام می‌داد. در نتیجه، این کلاس چندین دلیل برای تغییر داشت. | کلاس `PaymentProcessor` حذف شد و به واسط `PaymentService` و کلاس‌های تفکیک‌شده (مانند `CardPaymentService`، `PayPalPaymentService` و ...) تبدیل شد. |
| | کلاس `ReservationService` نیز مستقیماً به جزئیات پیاده‌سازی متدهای اختصاصی (مانند `payByCard`) در `PaymentProcessor` وابسته بود. | در `ReservationService`: وابستگی مستقیم به `PaymentProcessor` حذف شد. متغیر `processor` از نوع واسط `PaymentService` تعریف شد و اجرای نهایی عملیات پرداخت تنها با یک فراخوانی عمومی (`processor.processPayment(res.totalPrice());`) انجام گرفت. این کار مسئولیت اجرای دقیق پرداخت را به کلاس‌های جدید منتقل کرد. |
| | علاوه بر این، کلاس `ReservationService` نیز چندین مسئولیت مستقل را با هم ترکیب کرده بود: مدیریت رزرو و اعمال تخفیف، مدیریت پرداخت، و مدیریت اطلاع‌رسانی (سه دلیل برای تغییر). | برای `ReservationService`: وظایف اضافی به کلاس‌های تخصصی منتقل شدند: اعمال تخفیف به `DiscountStrategy` و چاپ فاکتور به `InvoicePrinter`. همچنین، وابستگی به سرویس‌ها (پرداخت، اطلاع‌رسانی) از طریق صدا زدن متد مربوطه انجام شد. این امر `ReservationService` را به یک هماهنگ‌کننده تبدیل کرد و SRP به طور کامل برقرار شد. |
| **OCP** (Open/Closed Principle) | مشکل در کد اولیه: کلاس `ReservationService` به شدت به جزئیات پیاده‌سازی متدهای پرداخت و اطلاع‌رسانی وابسته بود. این وابستگی از طریق استفاده از بلوک‌های `switch` برای مدیریت Enumsهای `PaymentMethods` و `Notifier` ایجاد شده بود. در نتیجه، افزودن هر روش پرداخت یا اعلان‌کننده جدید نیازمند تغییر کد داخلی متد `makeReservation` بود. | متد `makeReservation` اکنون اینترفیس‌ها (مانند `PaymentService` و `MessageSender`) را به عنوان پارامتر دریافت می‌کند. با این کار، کلاس `ReservationService` دیگر نیازی به دانستن نوع پرداخت یا اعلان‌کننده ندارد و فقط متدهای عمومی را فراخوانی می‌کند. این ساختار تضمین می‌کند که کلاس برای تغییر بسته و برای گسترش باز است. |

</div>
